# Documentation? What??

## How To Use
---
Keeping usability in mind (unlike literally every other fuzzer), all you need to run this are the commands:

```
cd /path/to/FuzzMyLife
```
and then
```
python3 src/main.py /path/to/binary /path/to/valid/input 
```

## Functionality / Techniques
---
Our fuzzer does two fuzzing techniques sequentially:  
### 1. Mutate values
---
Maintain the format of the sample input, and change the values of the fields one field at a time based on the field type. This attempts to find basic buffer overflow and format string vulnerabilities. The values it tries are:  
   - For integers: large negative number, small negative number, 0, small positive number, large positive number. These cases may induce a segfault if the sign is unexpected, or a buffer overflow if the number affects a buffer size.
   - For strings: very long string (for buffer overflow), long sequence of “%n” (for format string), “%1000000x” (for format string).   

Originally, the fuzzer tried all permutations of these values and the original values. We found that this created far too many permutations, so we changed to one field at a time for now. For each field, we try all testing cases while the rest of the fields remain as the sample values.

### 2. Vary the size of the input structure.  
---
For CSV, this means varying the number of fields per line, and the number of lines provided. For this part, the content of the fields doesn't matter.  
- To test the number of rows in a csv, the input size gets doubled while keeping the number of values per row equal. This only happens 8 times since the size of the inputs gets very large and starts to take a lot of time.   
- Additionally, the fuzzer tests to see if changing the number of values per row causes any errors. This is done by changing the number of values per row. The number of values per row has to divide the total number of values so the choice of values per row is generated by looping from 1 to the number of values and testing each valid value in the range.
## Design
---  
- First we find the type of the sample input by attempting to parse with Python's libraries. 
- When a parse is successful, we assume that that type is the correct type. To avoid false positives, we test the types in order from most to least restrictive.  
- Then we produce a dictionary of the values to fuzz in such a way that, after the values are changed by the fuzzing logic, the dictionary can be converted back into text that fits the format of the sample input.
## Bugs detected
---
- basic format string
- basic buffer overflow
- bugs caused due to larger amounts of input than a user would normally enter
## Next steps
---
- Mutate more than field at a time. A likely use case may be when the path to an overflow requires a large number provided as a length and a long string provided as the input.
- We should also test a larger range of numbers.
- We may need to follow and store discovered paths.