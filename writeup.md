## Functionality / Techniques
---
Our fuzzer does two fuzzing techniques sequentially: 
### 1. Mutate values
---
Maintains the format of the sample input, and changes the values of the fields one field at a time. This attempts to find basic buffer overflow and format string vulnerabilities. The values it tries are: 
  - integer values: large negative number, small negative number, 0, small positive number, large positive number. These cases may induce a segfault if the sign is unexpected, or a buffer overflow if the number affects a buffer size.
  - string values: very long strings of varying length, (for buffer overflow), long sequences of “%n” (for format string), “%1000000x” (for format string).  

Originally, the fuzzer tried all permutations of these values and the original values. This created far too many permutations, so we changed it to one field at a time for now. For each field, we try all testing cases (regardless of field type) while the rest of the fields remain as the sample values.
 
### 2. Vary the size of the input structure. 
---
For CSV files, this means varying the number of fields per line, and the number of lines provided. We also run the fuzzer on these new fields.
- To test the number of rows in a csv, the input size gets doubled while keeping the number of values per row equal. This only happens 8 times since the size of the inputs gets very large and starts to take a lot of time.  
- Additionally, the fuzzer tests to see if changing the number of values per row causes any errors. The number of values per row has to divide the total number of values so the choice of values per row is generated by looping from 1 to the number of values and testing each valid value in the range.
## Design
--- 
- First we find the type of the sample input by attempting to parse with Python's libraries.
- When a parse is successful, we assume that that type is the correct type. To avoid false positives, we test the types in order from most to least restrictive. 
- Then we produce a dictionary of the values to fuzz in such a way that, after the values are changed by the fuzzing logic, the dictionary can be converted back into text that fits the format of the sample input.
## Bugs detected
---
- basic format string
- basic buffer overflow
- bugs caused due to larger amounts of input than a user would normally enter (becomes buffer overflow due to logic error)
## Next steps
---
- Mutate more than a single field at a time. A likely use case may be when the path to an overflow requires a large number provided as a length and a long string provided as the input.
- We should also test a larger range of numbers.
- We may need to follow and store discovered paths.
- We also need to optimise the current actions.


